Java基础能力面试----面试常见问题

### 一数据结构与算法

#### 1、数据有哪几种基本存储结构？实际应用过程中该如何选择？



#### 2、排序算法有哪些？能说下快速排序的基本原理，时间复杂度是什么？

| 排序算法 | 平均时间复杂度 |
| :------: | :------------: |
| 冒泡排序 |     O(n2)      |
| 选择排序 |     O(n2)      |
| 插入排序 |     O(n2)      |
| 希尔排序 |    O(n1.5)     |
| 快速排序 |   O(N*logN)    |
| 归并排序 |   O(N*logN)    |
|  堆排序  |   O(N*logN)    |
| 基数排序 |   O(d(n+r))    |

**冒泡排序**：

比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

<img src="https://www.runoob.com/wp-content/uploads/2015/09/1240" alt="img" style="zoom:50%;" />

· java代码实现
```java
public static void BubbleSort(int[] arr){

    int temp;//临时变量
    for(int i=0; i<arr.length-1; i++){  //表示趟数，一共arr.length-1次。
        for(int j=arr.length-1; j>i; j--){
            if(arr[j] < arr[j-1]){
                temp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = temp;
            }
        }
    }
}
```

**选择排序**

在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换；
。。。
第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。

<img src="https://www.runoob.com/wp-content/uploads/2015/09/12401" alt="img" style="zoom: 50%;" />

java代码实现
```java
public static void select_sort(int array[],int lenth){
    for(int i=0;i<lenth-1;i++){
        int minIndex = i;
        for(int j=i+1;j<lenth;j++){
            if(array[j]<array[minIndex]){
                minIndex = j;
            }
        }
        if(minIndex != i){
            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
    }
}
```
**快速排序**

- 先从数列中取出一个数作为key值；
- 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
- 对左右两个小数列重复第二步，直至各区间只有1个数。

- 初始时 i = 0; j = 9; key=72

  由于已经将a[0]中的数保存到key中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。

  从j开始向前找一个比key小的数。当j=8，符合条件，

  a[0] = a[8] ; i++ ;

   

  将a[8]挖出再填到上一个坑a[0]中。

  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。

  这次从i开始向后找一个大于key的数，当i=3，符合条件，

  a[8] = a[3] ; j-- ;

   

  将a[3]挖出再填到上一个坑中。

  ```
  数组：72 - 6 - 57 - 88 - 60 - 42 - 83 - 73 - 48 - 85
   0   1   2    3    4    5    6    7    8    9
  ```

- 此时 i = 3; j = 7; key=72

  再重复上面的步骤，先从后向前找，再从前向后找。

  从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，

  a[3] = a[5]; i++;

  从i开始向后找，当i=5时，由于i==j退出。

  此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将key填入a[5]。

  ```
  数组：48 - 6 - 57 - 88 - 60 - 42 - 83 - 73 - 88 - 85
   0   1   2    3    4    5    6    7    8    9
  ```

- 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。

  ```
  <数组：48 - 6 - 57 - 42 - 60 - 72 - 83 - 73 - 88 - 85
   0   1   2    3    4    5    6    7    8    9
  ```

Java代码实现

```java
public static void quickSort(int a[],int l,int r) {
    if(l>=r)
        return;

    int i = l; int j = r; int key = a[l];//选择第一个数为key
    while(i<j){
        while(i<j && a[j]>=key) //从右向左找第一个小于key的值
            j--;
        if(i<j){
            a[i] = a[j];
            i++;
        }

        while(i<j && a[i]<key) //从左向右找第一个大于key的值
            i++;

        if(i<j){
            a[j] = a[i];
            j--;
        }
    }
    //i == j
    a[i] = key;
    quickSort(a, l, i-1);//递归调用
    quickSort(a, i+1, r);//递归调用
}
```

#### 3、二分查找的原理是什么？

**前提**：查找也是有特殊情况的，比如数列本身是有序的。这个有序数列是怎么产生的呢？有时它可能本身就是有序的，也有可能是我们通过之前所学的排序算法得到的。不管怎么说，我们现在已经得到了有序数列了并需要查找。这时[二分查找](http://data.biancheng.net/view/55.html)该出场了。二分查找（Binary Search）也叫作[折半查找](http://data.biancheng.net/view/55.html)。二分查找有两个要求，一个是数列有序，另一个是数列使用顺序存储结构（比如[数组](http://data.biancheng.net/view/181.html)）。

**原理**

二分查找的实现原理非常简单，首先要有一个有序的列表。但是如果没有，则该怎么办？可以使用排序算法进行排序。

以升序数列为例，比较一个元素与数列中的中间位置的元素的大小，如果比中间位置的元素大，则继续在后半部分的数列中进行二分查找；如果比中间位置的元素小，则在数列的前半部分进行比较；如果相等，则找到了元素的位置。每次比较的数列长度都会是之前数列的一半，直到找到相等元素的位置或者最终没有找到要找的元素。

我们先来想象一下，如果数列中有 3 个数，则先与第 2 个数进行比较，如果比第 2 个数大，则与第 2 个数右边的数列进行二分查找，这时这个数列就剩下一个数了，直接比较是否相等即可。所以在 3 个数的时候最多比较两次。

同理，在有 4 个数的时候，我们与中间数进行比较，一般中间数是首加末除以 2 算出来的，这时我们算出来的中间数是 (1+4)/2 等于 2，所以我们把要查找的数与第 2 个数比较，若比第 2 个数小，则直接与第 1 个数比较；否则与后面两个数进行二分查找，这时的中间数是 (3+4)/2 等于 3，也就是后半部分的第 1 个数。再接着进行比较，相等则找到相应的元素，小于则没有这个数（因为左边所有的数都已经判断过了），大于则继续向右查找。所以在 4 个数的时候最多比较 3 次。

以此类推，在 5 个数的时候最多查找 3 次，在 6 个数的时候也是最多查找 3 次。

下面我们以一个实际的例子来看看二分查找的操作过程。假设待查找数列为 1、3、5、7、9、11、19，我们要找的元素为 18，下面进行二分查找。首先待查数列如

[图](http://data.biancheng.net/view/200.html)

 1 所示，我们找到中间的元素 7（ (1+7)/2=4，第 4 个位置上的元素）。

![img](http://data.biancheng.net/uploads/allimg/181007/1-1Q00G330192T.jpg)
图 1 在待查序列中找到中间元素
中间元素为 7，我们要找的元素比 7 大，于是在后半部分查找，现在后半部分数列为 9、11、19，我们找到中间元素，如图 2 所示。

![img](http://data.biancheng.net/uploads/allimg/181007/1-1Q00G33049164.jpg)
图 2 在待查序列的后半部分找到中间元素
中间元素为 11，与 11 比较，比 11 大，则继续在后半部分查找，后半部分只有一个元素 19 了，这时直接与 19 比较，若不相等，则说明在数列中没有找到元素，结束查找。

对于这 7 个元素的数列，我们只查找并比较了 3 次，是不是比较次数很少呢？

**二分查找的特点及性能分析**

​        二分查找的平均查找长度 ASL 为 ((n+1)log2(n+1))/n-1，有的书上写的是 log2(n+1)-1，或者是 log2n，具体计算比较麻烦，这里就不讨论了。

二分查找有个很重要的特点，就是不会查找数列的全部元素，而查找的数据量其实正好符合元素的对数，正常情况下每次查找的元素都在一半一半地减少。所以二分查找的[时间复杂度](http://data.biancheng.net/view/2.html)为 `O(log2n)` 是毫无疑问的。当然，最好的情况是只查找一次就能找到，但是在最坏和一般情况下的确要比顺序查找好了很多。

**二分查找的适用场景**

​    二分查找要求数列本身有序，所以在选择的时候需要确认数列是否本身有序，如果无序，则还需要进行排序，确认这样的代价是否符合实际需求。

其实我们在获取一个列表的很多时候，可以直接使用数据库针对某个字段进行排序，在程序中需要找出某个值的元素时，就很适合使用二分查找了。

二分查找适合元素稍微多一些的数列，如果元素只有十几或者几十个，则其实可以直接使用顺序查找（当然，也有人在顺序查找外面用了一个或几个大循环，执行这几层大循环需要计算机执行百万、千万遍，没有考虑到机器的性能）。

一般对于一个有序列表，如果只需要对其进行一次排序，之后不再变化或者很少变化，则每次进行二分查找的效率就会很高；但是如果在一个有序列表中频繁地插入、删除数据，那么维护这个有序列表会让人很累，其实有更好的方案，别着急，我们慢慢想。

#### 4、衡量一个算法的好坏有哪几个维度？



#### 5、二叉树遍历：如何遍历一颗二叉树，有哪几种方法？如何实现？

二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。四种主要的遍历思想为：

前序遍历：根结点 ---> 左子树 ---> 右子树

中序遍历：左子树---> 根结点 ---> 右子树

后序遍历：左子树 ---> 右子树 ---> 根结点

层次遍历：只需按层次遍历即可

例如，求下面二叉树的各种遍历

![img](https://img-blog.csdn.net/20150204101904649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTXlfSm9icw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

前序遍历：1  2  4  5  7  8  3  6 

中序遍历：4  2  7  5  8  1  3  6

后序遍历：4  7  8  5  2  6  3  1

层次遍历：1  2  3  4  5  6  7  8

**[二叉树的遍历详解](https://zhuanlan.zhihu.com/p/56895993)**

#### *6、TopK问题：从1个超大规模（1000亿）的样本中选择Top100个数，该如何实现？



二、Java

1、Java容器

​    1)Java有哪些常用的容器，如何按场景选择？如：Map有HashMap、LinkedHashMap、TreeMap



Java 容器都有哪些？

Collection

|　　├AbstractCollection  对Collection接口的最小化抽象实现

|　　│ 

|　　├List  有序集合

|　　│-├AbstractList  有序集合的最小化抽象实现 

|　　│-├ArrayList  基于数组实现的有序集合

|　　│-├LinkedList  基于链表实现的有序集合

|　　│-└Vector  矢量队列

|　　│　└Stack  栈，先进后出

|　　│

|　　├Set  不重复集合

|　　│├AbstractSet  不重复集合的最小化抽象实现

|　　│├HashSet  基于hash实现的不重复集合，无序

|　　│├LinkedHashSet  基于hash实现的不重复集合，有序

|　　│└SortedSet  可排序不重复集合

|　　│   └NavigableSet  可导航搜索的不重复集合

|　　│     └TreeSet  基于红黑树实现的可排序不重复集合

|　　│

|　　├Queue  队列

|　　│├AbstractQueue  队列的核心实现

|　　│├BlockingQueue  阻塞队列

|　　│└Deque  可两端操作线性集合

| 

 

Map  键值映射集合

|　　├AbstractMap  键值映射集合最小化抽象实现

|　　├Hashtable  基于哈希表实现的键值映射集合，key、value均不可为null

|　　├HashMap  类似Hashtable，但方法不同步，key、value可为null

|　　   └LinkedHashMap  根据插入顺序实现的键值映射集合

|　　├IdentityHashMap  基于哈希表实现的键值映射集合，两个key引用相等==，认为是同一个key

|　　├SortedMap   可排序键值映射集合

|　　   └NavigableMap  可导航搜索的键值映射集合

|　   └WeakHashMap  弱引用建，不阻塞被垃圾回收器回收，key回收后自动移除键值对

![img](C:\Users\fwx5329455\Downloads\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21laXNtNQ==,size_16,color_FFFFFF,t_70)

可以比较的点：

- 有序、无序
- 可重复、不可重复
- 键、值是否可为null
- 底层实现的数据结构（数组、链表、哈希...）
- 线程安全性

2、Java排序

​    1） 如何对对象类型的数据进行排序？

​    2）Java.util.Arrays.sort库函数内部是用什么排序算法实现的？



3、Java多线程

​    1） 说下进程和线程的区别，为什么要引入多线程，那些场景需要考虑使用多线程？



​    2） Java中如何使用多线程？



​    3）如何使用锁来保护共享变量



4、Java垃圾回收

​    1） 说下对java垃圾回收机制的理解



​    2） Java既然有垃圾回收机制，是不是就不用担心内存泄漏了？ 什么情况可能会有内存泄漏？



5、Java高级调试：

​    1） 如果你的项目所负责的程序发布到现网生产环境后，程序在运行过程中CPU占用率非常高，可能会是什么问题？如何排除是否有问题？



​    2） 如果你的项目所负责的程序发布到现网生产环境后，程序在运行过程中内存占用率非常高，可能会是什么问题？如何排除是否有问题？



6、设计模式

​    1） 熟悉哪几种设计模式？说下对这几种设计模式的理解？可以用来解决什么问题？



​    2）为什么要使用设计模式，谈下自己的理解？



三、数据库

1、你熟悉哪几种数据库和数据库中间件？例如MySQL、MyBatis？谈下使用数据库中间件相比直接使用JDBC有哪些好处？



2、你是否独立设计过数据库表结构？关系型数据库设计需要遵守哪些范式、谈下对3NF的理解以及为什么要遵守3NF



3、如果你要在现网生产环境中给某张数据库表指定位置增加1列，并且不能改变原来的字段顺序，实现方法是什么，需要注意什么？



4、单张表的数据量超过多大可能需要考虑性能问题？如何解决超大表的性能问题？





四、数据仓库

1、你是否了解数据仓库？谈下OLTP和OLAP的区别，例如从数据建模方法上比较？



2、是否了解数据仓库分层架构，分别谈下对贴源层、主题层、集市层的理解？



3、什么是星型建模？星型建模的方法是什么，需要注意什么？



4、给定一个在线购物场景。购物过程涉及”用户、商品、购物车、订单“等几个关键业务对象、如何使用星型建模进行建模，可能需要哪些维度表、事实表？



5、如何处理维度表中的数据缓慢变化？例如：商品维表中，商品价格发生了变化，如何在维度表中进行缓慢变化处理？



6、事实表分哪几类？分别说下对事物事实表、周期快照事实表、累计快照事实表的理解
